import * as vscode from 'vscode';
import * as PATH from 'path';
import { assetsConfig } from "./assets_config";
import { assetsFileWriter } from './assets_file_writer';
import { toSnakeCase, toUpperCamelCase } from './name_utils';

class AssetsGenerator {
    async generate(): Promise<boolean> {
        try {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders) { return false; }
            const workspaceFolder = workspaceFolders[0];

            const projectUri = workspaceFolder.uri;
            const assetsUri = vscode.Uri.joinPath(workspaceFolder.uri, assetsConfig.assetsPath);
            const outputDirUri = vscode.Uri.joinPath(projectUri, assetsConfig.outputPath);
            const outputFileUri = vscode.Uri.joinPath(outputDirUri, `${assetsConfig.outputName}.dart`);
            const className = assetsConfig.className();

            const content = await this.generateFileContent(className, projectUri, assetsUri, assetsConfig.ignoreExt);

            await assetsFileWriter.write(outputFileUri, content);
            return true;
        } catch (e) {
            console.error(e);
            return false;
        }
    }

    private async generateFileContent(
        className: string,
        projectPath: vscode.Uri,
        assetsPath: vscode.Uri,
        ignoreExt: boolean
    ): Promise<string> {
        let fileContent = '';
        fileContent += '// Generated by Flutter Assets';
        fileContent += '\n\n';
        fileContent += '// ignore_for_file: unused_field, camel_case_types, non_constant_identifier_names';
        fileContent += '\n\n';

        try {
            const stat = await vscode.workspace.fs.stat(assetsPath);
            if (stat.type !== vscode.FileType.Directory) {
                fileContent += "// 'assets-path' should be a dir!";
            } else {
                fileContent += await this.generateClassesContent(className, projectPath, assetsPath, 0, ignoreExt);
            }
        } catch {
        }

        return fileContent;
    }

    private async generateClassesContent(
        className: string,
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        deepth: number,
        ignoreExt: boolean
    ): Promise<string> {
        let content = await this.generateClassContent(className, projectPath, currPath, deepth, ignoreExt);

        const children = await vscode.workspace.fs.readDirectory(currPath);

        for (let i = 0; i < children.length; i++) {
            const [childName, childType] = children[i];
            const childPath = vscode.Uri.joinPath(currPath, childName);

            if (childType !== vscode.FileType.Directory) { continue; }

            if (childName.match('[0-9.]+?x')) { continue; }

            const relativePath = PATH.relative(projectPath.fsPath, childPath.fsPath);
            const className = this.toClassName(relativePath);

            content += '\n';
            content += await this.generateClassesContent(className, projectPath, childPath, deepth + 1, ignoreExt);
        }

        return content;
    }

    private async generateClassContent(
        className: string,
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        deepth: number,
        ignoreExt: boolean
    ): Promise<string> {
        let classContent = `class ${className} {`;
        classContent += `\n  const ${className}._();`;

        const classLines = await this.generateFieldLines(projectPath, currPath, deepth === 0, ignoreExt, true);
        for (let i = 0; i < classLines.length; i++) {
            if (i === 0) { classContent += `\n`; }
            const line = classLines[i];
            classContent += `\n  ${line}`;
        }

        const stringLines = await this.generateFieldLines(projectPath, currPath, deepth === 0, ignoreExt, false);
        for (let i = 0; i < stringLines.length; i++) {
            if (i === 0) { classContent += `\n`; }
            const line = stringLines[i];
            classContent += `\n  ${line}`;
        }

        classContent += `\n}\n`;

        return classContent;
    }

    private async generateFieldLines(
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        staticField: boolean,
        ignoreExt: boolean,
        onlyClassOrString: boolean,
    ): Promise<string[]> {
        const lines = new Array<string>();
        const stat = await vscode.workspace.fs.stat(currPath);
        if (stat.type === vscode.FileType.Directory) {
            const children = await vscode.workspace.fs.readDirectory(currPath);
            for (let i = 0; i < children.length; i++) {
                const [childName, childType] = children[i];

                if (childName.startsWith('.')) { continue; }
                if (childName.match('[0-9.]+?x')) { continue; }

                const childPath = vscode.Uri.joinPath(currPath, childName);

                const relativePath = PATH.relative(projectPath.fsPath, childPath.fsPath);
                const className = this.toClassName(relativePath);
                const fieldName = this.toFieldName(relativePath, ignoreExt);
                const assetPath = this.toAssetsPath(relativePath);

                if (onlyClassOrString && childType === vscode.FileType.Directory) {
                    if (staticField) {
                        lines.push(`static const ${fieldName} = ${className}._();`);
                    } else {
                        lines.push(`final ${fieldName} = const ${className}._();`);
                    }
                    continue;
                }

                if (!onlyClassOrString && childType === vscode.FileType.File) {
                    if (staticField) {
                        lines.push(`static const ${fieldName} = '${assetPath}';`);
                    } else {
                        lines.push(`final ${fieldName} = '${assetPath}';`);
                    }
                    continue;
                }
            }
        }
        return lines;
    }

    private toClassName(path: string): string {
        return '_' + toSnakeCase(path.split(PATH.sep));
    }

    private toAssetsPath(path: string): string {
        return path.split(PATH.sep).join('/');
    }

    private toFieldName(path: string, ignoreExt: boolean): string {
        let basename;
        if (ignoreExt) {
            basename = PATH.basename(path, PATH.extname(path));
        } else {
            basename = PATH.basename(path);
        }
        return toSnakeCase(basename.split('.'));
    }
}

export var assetsGenerator = new AssetsGenerator();