import * as vscode from 'vscode';
import * as FS from 'fs';
import * as PATH from 'path';
import { Config } from "./config";

export class AssetsGenerator {
    static instance = new AssetsGenerator();

    generate(): void {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) { return; }
        const workspaceFolder = workspaceFolders[0];

        const projectPath = workspaceFolder.uri;

        const config = Config.instance;

        const assetsPath = vscode.Uri.joinPath(workspaceFolder.uri, config.assetsPath);

        const outputDirPath = vscode.Uri.joinPath(projectPath, config.outputPath);
        const outputPath = vscode.Uri.joinPath(outputDirPath, `${config.outputName}.dart`);

        if (!FS.existsSync(outputDirPath.fsPath)) {
            FS.mkdirSync(outputDirPath.fsPath);
        }

        const content = this.generateFileContent(config.className(), projectPath, assetsPath, config.ignoreExt);
        FS.writeFileSync(outputPath.fsPath, content);
    }

    private generateFileContent(
        className: string,
        projectPath: vscode.Uri,
        assetsPath: vscode.Uri,
        ignoreExt: boolean
    ): string {
        if (!FS.existsSync(assetsPath.fsPath)) {
            return '';
        }

        const stat = FS.statSync(assetsPath.fsPath);
        if (!stat.isDirectory()) {
            throw Error("'assets-path' is not a dir!");
        }

        let fileContent = '';
        fileContent += '// Generated by Flutter Assets';
        fileContent += '\n\n';
        fileContent += '// ignore_for_file: unused_field, camel_case_types, non_constant_identifier_names';
        fileContent += '\n\n';
        fileContent += this.generateClassesContent(className, projectPath, assetsPath, 0, ignoreExt);

        return fileContent;
    }

    private generateClassesContent(
        className: string,
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        deepth: number,
        ignoreExt: boolean
    ): string {
        let content = this.generateClassContent(className, projectPath, currPath, deepth, ignoreExt);

        const childPaths = FS.readdirSync(currPath.fsPath);
        for (let i = 0; i < childPaths.length; i++) {
            const childName = childPaths[i];
            const childPath = vscode.Uri.joinPath(currPath, childName);

            const stat = FS.statSync(childPath.fsPath);
            if (!stat.isDirectory()) { continue; }

            if (childName.match('[0-9.]+?x')) { continue; }
            if (childName.match('dark')) { continue; }

            const relativePath = PATH.relative(projectPath.fsPath, childPath.fsPath);
            const className = this.toClassName(relativePath);

            content += '\n';
            content += this.generateClassesContent(className, projectPath, childPath, deepth + 1, ignoreExt);
        }

        return content;
    }

    private generateClassContent(
        className: string,
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        deepth: number,
        ignoreExt: boolean
    ): string {
        let classContent = `class ${className} {`;
        classContent += `\n  const ${className}._();`;

        const classLines = this.generateFieldLines(projectPath, currPath, deepth === 0, ignoreExt, true);
        for (let i = 0; i < classLines.length; i++) {
            if (i === 0) { classContent += `\n`; }
            const line = classLines[i];
            classContent += `\n  ${line}`;
        }

        const stringLines = this.generateFieldLines(projectPath, currPath, deepth === 0, ignoreExt, false);
        for (let i = 0; i < stringLines.length; i++) {
            if (i === 0) { classContent += `\n`; }
            const line = stringLines[i];
            classContent += `\n  ${line}`;
        }

        classContent += `\n}\n`;

        return classContent;
    }

    private generateFieldLines(
        projectPath: vscode.Uri,
        currPath: vscode.Uri,
        staticField: boolean,
        ignoreExt: boolean,
        onlyClassOrString: boolean,
    ): string[] {
        const lines = new Array<string>();
        if (!FS.existsSync(currPath.fsPath)) {
            return lines;
        }
        const stat = FS.statSync(currPath.fsPath);
        if (stat.isFile()) {
            return lines;
        }
        if (stat.isDirectory()) {
            const childPaths = FS.readdirSync(currPath.fsPath);
            for (let i = 0; i < childPaths.length; i++) {
                const childName = childPaths[i];
                if (childName.startsWith('.')) { continue; }

                if (childName.match('[0-9.]+?x')) { continue; }
                if (childName.match('dark')) { continue; }

                const childPath = vscode.Uri.joinPath(currPath, childName);
                if (!FS.existsSync(childPath.fsPath)) { continue; }

                const relativePath = PATH.relative(projectPath.fsPath, childPath.fsPath);
                const className = this.toClassName(relativePath);
                const fieldName = this.toFieldName(relativePath, ignoreExt);
                const assetPath = this.toAssetsPath(relativePath);

                const stat = FS.statSync(childPath.fsPath);

                if (onlyClassOrString && stat.isDirectory()) {
                    if (staticField) {
                        lines.push(`static const ${fieldName} = ${className}._();`);
                    } else {
                        lines.push(`final ${fieldName} = const ${className}._();`);
                    }
                    continue;
                }

                if (!onlyClassOrString && stat.isFile()) {
                    if (staticField) {
                        lines.push(`static const ${fieldName} = '${assetPath}';`);
                    } else {
                        lines.push(`final ${fieldName} = '${assetPath}';`);
                    }
                    continue;
                }
            }
        }
        return lines;
    }

    private toClassName(path: string): string {
        const splits = path.split(PATH.sep);
        let name = '';
        for (let i = 0; i < splits.length; i++) {
            const split = splits[i];
            if (split.length === 0) { continue; }
            name += '_';
            name += split;
        }
        return name;
    }

    private toAssetsPath(path: string): string {
        const splits = path.split(PATH.sep);
        let name = '';
        for (let i = 0; i < splits.length; i++) {
            const split = splits[i];
            if (split.length === 0) { continue; }
            if (name.length !== 0) { name += '/'; }
            name += split;
        }
        return name;
    }

    private toFieldName(path: string, ignoreExt: boolean): string {
        let basename;
        if (ignoreExt) {
            basename = PATH.basename(path, PATH.extname(path));
        } else {
            basename = PATH.basename(path);
        }

        const splits = basename.split('.');
        let name = '';
        for (let i = 0; i < splits.length; i++) {
            const split = splits[i];
            if (split.length === 0) { continue; }
            if (name.length !== 0) { name += '_'; }
            name += split;
        }

        return name;
    }
}